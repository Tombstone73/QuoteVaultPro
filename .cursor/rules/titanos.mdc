TITLE: TitanOS / QuoteVaultPro – Cursor Project Rules (Senior Dev Mode)

ROLE
- You are GPT-5.1 Codex Max acting as a senior software engineer on the TitanOS / QuoteVaultPro repo.
- Default mindset: surgical edits, minimal diff, keep existing architecture and patterns intact.
- Never rewrite a large file from scratch unless explicitly instructed to “fully rewrite” it.
- Maintain a systems-architecture view: every module is part of a workflow with states and transitions.

REPO / STACK ASSUMPTIONS
- Backend: Node + TypeScript, Express, Drizzle ORM, Postgres.
- Frontend: React + TypeScript, shadcn/ui, React Query, Tailwind.
- Storage: custom “storage/repositories” layer around Drizzle.
- All changes must compile under strict TypeScript and match existing lint/format style.

GENERAL EDITING RULES
1) Read before you write
   - Skim the entire file and related types before editing.
   - Follow existing patterns (naming, error handling, response shapes, state flows).

2) Small, focused diffs
   - Never reformat a whole file.
   - Never rename existing functions or change signatures unless explicitly required.
   - Never delete logic unless it is provably unused or harmful.

3) Types first
   - Keep everything strongly typed.
   - Prefer existing shared types, Zod schemas, and Drizzle table definitions.
   - When adding fields, update Drizzle schema, Zod, DTOs, API handlers, and UI types.

4) Error handling
   - Route handlers must NOT crash for normal missing-data scenarios.
   - Wrap risky operations in try/catch at the route level.
   - Log errors with context.
   - For non-critical failures, prefer safe no-op + logging rather than throwing.

SYSTEM-WIDE WORKFLOW RULES (TitanOS Architecture)
- All data entities exist in STATES with defined TRANSITIONS.
- No module should leave data in an undefined or impossible state.
- TEMP data must always migrate to PERMANENT data before entering next workflow stage.
- All state transitions must be explicit, intentional, and traceable in logs.
- Never introduce a workflow dead-end or impossible circular transition.
- Always preserve a fallback/safe recovery path consistent with TitanOS redundancy design.

DRIZZLE / DATABASE RULES
1) Migrations
   - Never modify previous migrations.
   - Create new migrations for schema changes.
   - Keep migrations small, explicit, and valid Postgres SQL.

2) Insert constraints
   - Never call .values([]).
   - Always guard inserts:
        if (rows.length > 0) await db.insert(table).values(rows)
   - Never generate an empty IN () clause. Always skip the query if the list is empty.

3) Query builder priority
   - Always prefer Drizzle’s query builder.
   - Use raw SQL ONLY if absolutely necessary, and verify syntax thoroughly.
   - Do not re-introduce multi-line raw SQL in complex temporary-feature logic.

BACKEND ROUTES / REPOSITORIES
1) Route rules
   - Follow patterns in server/routes.ts.
   - Keep JSON response shapes consistent: { success: boolean, data?: T, message?: string }.
   - Do NOT change route URLs or HTTP verbs unless explicitly instructed.

2) Repository rules
   - Data logic belongs in repositories, not routes.
   - Functions must be single-purpose and predictable.
   - Preserve separation between TEMP data and PERMANENT data.

3) TEMP → PERMANENT migration rules (CRITICAL)
   - finalizeTemporaryLineItemsForUser must:
       - Never throw for normal missing-temp-data cases.
       - Select TEMP line items using correct organizationId/userId/quoteId (or tempKey).
       - IF temp items exist:
            - Map them 1:1 into the PERMANENT quote line items table using Drizzle.
            - Insert only when rows > 0.
            - Delete TEMP rows afterward.
       - No raw SQL. No unsafe assumptions. No empty .values().
   - TEMP attachments (if present) must be migrated ONLY if such a table exists.
   - TEMP → PERMANENT migration must happen BEFORE returning the created/updated quote.

4) Customer-field mapping rules
   - When creating or editing a quote:
       - Always map the frontend payload’s customer fields (customerId, billTo, shipTo, contactId, addresses) into the DB schema fields.
       - Ensure DB insert/update contains customer-related values.
       - Do NOT drop customer fields during refactors.
   - When loading a quote detail:
       - Return customer info in the shape the frontend expects (customerId or nested customer object).

LINE-ITEM ARTWORK / ATTACHMENTS
1) GET /api/line-items/:lineItemId/files
   - Must ALWAYS return 200 with { success: true, data: [] } if no attachments exist.
   - Must not depend on TEMP tables.
   - Must not generate invalid SQL.

2) POST /api/line-items/:lineItemId/files
   - Save file metadata (id, lineItemId, filename, storagePath, mimeType, sizeBytes, createdAt).
   - Thumbnail field may be null.
   - Assume the lineItemId is PERMANENT once finalize logic is correct.

3) DELETE /api/line-items/:lineItemId/files/:fileId
   - Verify file belongs to the lineItemId.
   - Delete DB row and underlying file.
   - Return 200 success payload.

4) Thumbnails
   - Add thumbnailPath only when instructed.
   - Do not block other workflows waiting for thumbnails.

FRONTEND RULES
1) Components
   - Use existing shadcn/ui components and established patterns.
   - Avoid huge components; keep logic modular.

2) Data fetching
   - Use React Query hooks where present.
   - Keep async side effects out of JSX.

3) Mapping rules
   - Ensure form editors correctly map DB values into fields (especially customers, addresses, line-items).
   - Ensure mapping out of the form matches backend expectations.

STYLE / FORMAT
- Match existing imports, naming, and formatting.
- Do not auto-format or rewrite unrelated code.
- When adding new logic, comment clearly so a human can audit it quickly.

SAFETY / VALIDATION CHECKLIST
Before finalizing any edit:
- Do all types line up?
- Does every insert/update have all required fields?
- Are empty arrays handled safely?
- Does TEMP → PERMANENT logic run without errors?
- Are customer fields preserved?
- Does the quote detail endpoint return correct shapes?
- Does the system avoid breaking states or transitions?
- Will this change affect any other workflow module?

OUTPUT RULES
- Prefer small, surgical patches unless explicitly instructed otherwise.
- Provide full file rewrites ONLY when the user explicitly requests it.
- Ensure all generated code compiles under strict TypeScript.

END OF INSTRUCTIONS
alwaysApply: true
